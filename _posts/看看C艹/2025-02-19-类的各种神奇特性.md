---
title: 类的各种神奇特性
tags:
  - cpp
excerpt: 有关C++的类的一点简单的东西
---
## 类的三种成员

### `public`和`private`

这两个个个都会，一个是谁都能看，一个是只有自己能看
### `protected`

`protected`(prəˈtektəd)是`protect`(prəˈtekt)的过去式和过去分词，意为v.保护；防护；（制定法律）保护；（通过征关税）保护（国内企业）

所以说呢，被保护的成员只能被类自己或者类的~~子子孙孙~~派生类看
## 对象的生与死

### 构造函数
**为什么，一定要在类内声明啊**

对于一个类，如果要像一个函数一样传入参数然后对其初始化的话，就要用到**构造函数**，就是说这个类要怎么用传入的参数

但难绷的是，为什么C艹的构造函数的参数必须要写在类里面，而不能像函数或者别的语言那样写在最前面呢

#### 经典原味
下面就是一个构造函数的例子
```C++
class MyClass {
public:
    int a, b;
	
//  MyClass(int x, int y) : a(x), b(y) {} 
    MyClass(int x, int y) {
        a = x;
        b = y;
    }
};
```
如果只是赋值的话，这两种写法是等价的

#### 米家口味
若是想在类外实现也未尝不可
```C++
class MyClass {
public:
    int a, b;
    
    MyClass(int x, int y);
};

MyClass::Myclass(int x, int y) {
    a = x; b = y;
}

```

#### 可部分不自选口味
对于某些神奇的类，有的参数是不一定要传入的，就可以实现多种选择方案
```C++
class MyClass {
public:
    int a, b;
    
    MyClass(int x, int y) : a(x), b(y) {}
    
    Myclass(int x) : Myclass(x, 0) {}
};
```

#### 工厂源头口味
>**静态工厂方法**（Static Factory Method）是一种创建对象的设计模式，它通过一个静态方法创建并返回类的实例，而不是直接调用类的构造函数。这种方法提供了更灵活的对象创建方式，适合复杂对象初始化的场景。

这多少有点太复杂了……
### 析构函数
~~谁起的这名字，望文生义不了一点~~

有生便有灭，虽然我不知道为什么构造和析构能对得上

析构函数就是在对象销毁时自动执行的函数，用来释放内存之类的资源防止电脑爆掉

和构造函数不同的地方就是会多一个`~`，比如`~MyClass()`

请看
```C++
class MyClass {
public:
    int a, b, *arr;

    MyClass(int x, int y) {
        arr = new int[x];
        a = x; b = y;
    }
    
    ~Myclass() {
        delete[] arr;
    }
};
```

当这个类的对象没用了的时候，被`new`分配来的内存就会被`delete`掉，真是太棒了


## 类的继承

### 普通的？多的？虚的？

还挺复杂
#### 一般的继承

C艹里面继承用的是冒号`:`，也就是`派生类 : 基类`，非常的简单（

不过基类前面可能经常要加上诸如`public`，`protected`之类的，不然`class`的默认继承会把基类所有的成员变成`private`哦 （相对的，`struct`的默认继承会把能`public`的都`public`了）

当然，本来就不给看的就是不给看哦
#### 一次买够

和某些面向对象语言不同的是，C艹可以干出**多继承**这种比较反直觉的操作

### 论上面两函数的继承

#### 构造

一般而言，构造函数是不会自动继承的，除非在C++11及以后使用`using`来**强调**你要继承

比如

```cpp
class MyClass {
public:
    int a, b;

	MyClass(int x, int y) : a(x), b(y) {} 
};

class YourClass : public Myclass {
public:
	int c;

	using MyClass::MyClass; // 哇还有命名空间
}
```

这好吗？至少能这么做也是不错的

#### 析构

析构函数就不用想那么多了，因为无论怎么样对象死掉的时候都会调用**派生类和基类**的析构函数，所以压根不用继承